namespace GetStoreApp.WindowsAPI.PInvoke.Ole32
{
    /// <summary>
    /// 确定用于对此线程创建的对象的传入调用的并发模型。 此并发模型可以是单元线程模型，也可以是多线程模型。
    /// 通过调用 CoInitializeEx 初始化线程时，可以通过将 COINIT 的其中一个成员指定为其第二个参数来选择将其初始化为单元线程还是多线程。 这指定如何处理该线程创建的任何对象的传入调用，即对象的并发性。
    /// 单元线程在允许多个线程执行的同时，通过要求对此线程创建的对象方法的调用始终在同一线程（即创建它们的单元/线程）上运行来序列化所有传入调用。 此外，调用只能到达消息队列边界。 由于这种序列化，通常不需要将并发控制写入对象的代码中，只是为了避免在处理期间调用 PeekMessage 和 SendMessage ，这些调用不得被其他方法调用或对同一单元/线程中其他对象的调用中断。
    /// 多线程 (也称为自由线程) 允许在任何线程上运行对此线程创建的对象方法的调用。 没有对调用进行序列化，即对同一方法、同一对象或同时发生的许多调用。 多线程对象并发提供最高性能，并充分利用多处理器硬件进行跨线程、跨进程和跨计算机调用，因为对对象的调用不会以任何方式序列化。 但是，这意味着对象的代码必须强制实施其自己的并发模型，通常通过使用同步基元，例如关键部分、信号灯或互斥体。 此外，由于 对象不控制访问它的线程的生存期，因此不会将特定于线程的状态存储在对象中， (线程本地存储) 。
    /// </summary>
    public enum COINIT
    {
        /// <summary>
        /// 初始化单元线程对象并发的线程。
        /// </summary>
        COINIT_APARTMENTTHREADED = 0x2,

        /// <summary>
        /// 初始化多线程对象并发的线程。
        /// </summary>
        COINIT_MULTITHREADED = 0x0,

        /// <summary>
        /// 禁用 DDE 以支持 OLE1。
        /// </summary>
        COINIT_DISABLE_OLE1DDE = 0x4,

        /// <summary>
        /// 增加内存使用量，以尝试提高性能。
        /// </summary>
        COINIT_SPEED_OVER_MEMORY = 0x8,
    }
}
